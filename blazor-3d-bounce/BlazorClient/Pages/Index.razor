@page "/"
@inject IRenderingService RenderingService
@inject IRigidPhysicsService RigidPhysics
@inject ISoftPhysicsService SoftPhysics
@inject IInteropService Interop
@inject ISceneStateService SceneState
@inject ISimulationLoopService SimulationLoop
@implements IAsyncDisposable

<Toolbar OnSpawnRigid="SpawnRigidBody" 
         OnSpawnSoft="SpawnSoftBody" 
         OnPlayPause="TogglePlayPause"
         OnReset="ResetScene"
         OnStep="StepSimulation"
         OnLoadPreset="LoadPreset"
         IsPaused="@SceneState.Settings.IsPaused" />

<div class="sidebar-panel panel">
    <div class="panel-header">
        <span><i class="bi bi-plus-circle"></i></span>
        <span>Spawn Objects</span>
    </div>
    
    <div class="panel-section">
        <div class="panel-section-title">Rigid Bodies</div>
        <div class="spawn-grid">
            <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Sphere)">
                <span class="spawn-btn-icon"><i class="bi bi-circle-fill"></i></span>
                <span class="spawn-btn-label">Sphere</span>
            </button>
            <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Box)">
                <span class="spawn-btn-icon"><i class="bi bi-box-fill"></i></span>
                <span class="spawn-btn-label">Box</span>
            </button>
            <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Capsule)">
                <span class="spawn-btn-icon"><i class="bi bi-capsule"></i></span>
                <span class="spawn-btn-label">Capsule</span>
            </button>
            <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Cylinder)">
                <span class="spawn-btn-icon"><i class="bi bi-cylinder"></i></span>
                <span class="spawn-btn-label">Cylinder</span>
            </button>
        </div>
    </div>
    
    <div class="panel-section">
        <div class="panel-section-title">Soft Bodies</div>
        <div class="spawn-grid">
            <button class="spawn-btn" @onclick="() => SpawnSoftBody(SoftBodyType.Cloth)" disabled="@(!_softBodyAvailable)">
                <span class="spawn-btn-icon"><i class="bi bi-grid-3x3"></i></span>
                <span class="spawn-btn-label">Cloth</span>
            </button>
            <button class="spawn-btn" @onclick="() => SpawnSoftBody(SoftBodyType.Volumetric)" disabled="@(!_softBodyAvailable)">
                <span class="spawn-btn-icon"><i class="bi bi-dice-3-fill"></i></span>
                <span class="spawn-btn-label">Jelly</span>
            </button>
        </div>
        @if (!_softBodyAvailable)
        {
            <p class="text-warning mt-sm" style="font-size: 0.75rem;">
                <i class="bi bi-exclamation-triangle"></i> Soft body physics unavailable. Using rigid approximation.
            </p>
        }
    </div>
    
    <div class="panel-section">
        <div class="panel-section-title">Scene Objects</div>
        <div class="object-list">
            @foreach (var body in SceneState.RigidBodies)
            {
                <div class="object-item @(body.IsSelected ? "selected" : "")" 
                     @onclick="() => SelectObject(body.Id)">
                    <span class="object-icon rigid"><i class="bi bi-circle-fill"></i></span>
                    <span class="object-name">@body.Name</span>
                    <span class="object-type">@body.PrimitiveType</span>
                </div>
            }
            @foreach (var body in SceneState.SoftBodies)
            {
                <div class="object-item @(body.IsSelected ? "selected" : "")" 
                     @onclick="() => SelectObject(body.Id)">
                    <span class="object-icon soft"><i class="bi bi-droplet-fill"></i></span>
                    <span class="object-name">@body.Name</span>
                    <span class="object-type">@body.Type</span>
                </div>
            }
            @if (SceneState.RigidBodies.Count == 0 && SceneState.SoftBodies.Count == 0)
            {
                <div class="inspector-empty" style="height: 100px;">
                    <span class="text-muted">No objects in scene</span>
                </div>
            }
        </div>
    </div>
</div>

<Viewport @ref="_viewport" 
          CanvasId="renderCanvas" 
          OnObjectSelected="SelectObject"
          Fps="@SimulationLoop.Fps"
          PhysicsTimeMs="@SimulationLoop.PhysicsTimeMs"
          RigidBodyCount="@SceneState.RigidBodies.Count"
          SoftBodyCount="@SceneState.SoftBodies.Count"
          ActiveBackend="@_activeBackend"
          GpuInfo="@_gpuInfo"
          IsFallbackRenderer="@_isFallbackRenderer"
          ShowRendererBadge="@SceneState.RenderSettings.ShowRendererInfo" />

<Inspector SelectedRigidBody="@SceneState.SelectedRigidBody"
           SelectedSoftBody="@SceneState.SelectedSoftBody"
           SimulationSettings="@SceneState.Settings"
           RenderSettings="@SceneState.RenderSettings"
           OnRigidBodyChanged="UpdateRigidBody"
           OnSoftBodyChanged="UpdateSoftBody"
           OnSettingsChanged="UpdateSettings"
           OnRenderSettingsChanged="UpdateRenderSettings"
           OnDeleteObject="DeleteSelectedObject" />

<Stats FPS="@SimulationLoop.Fps" 
       PhysicsTimeMs="@SimulationLoop.PhysicsTimeMs" 
       RigidBodyCount="@SceneState.RigidBodies.Count"
       SoftBodyCount="@SceneState.SoftBodies.Count" />

@code {
    private Viewport? _viewport;
    private bool _initialized;
    private bool _softBodyAvailable;
    private Action? _sceneStateChangedHandler;
    private Action? _simulationStateChangedHandler;
    
    // Renderer info
    private string _activeBackend = "Unknown";
    private string? _gpuInfo;
    private bool _isFallbackRenderer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            await InitializeAsync();
        }
    }

    private async Task InitializeAsync()
    {
        try
        {
            Console.WriteLine("Starting initialization...");
            
            // Initialize interop first
            try
            {
                await Interop.InitializeAsync("renderCanvas");
                Console.WriteLine("Interop initialized");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Interop initialization failed: {ex.Message}");
                // Continue without interop - physics will still work
            }

            // Initialize rendering
            try
            {
                await RenderingService.InitializeAsync("renderCanvas", SceneState.RenderSettings);
                Console.WriteLine("Rendering initialized");
                
                // Get renderer info
                await UpdateRendererInfoAsync();
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Rendering initialization failed: {ex.Message}");
                Console.Error.WriteLine("Physics will still work, but no visuals will be displayed.");
                // Don't return - continue to initialize physics
            }

            // Initialize rigid physics - this is required
            await RigidPhysics.InitializeAsync(SceneState.Settings);
            await RigidPhysics.CreateGroundAsync(0.3f, 0.5f);
            Console.WriteLine("Rigid physics initialized");

            // Initialize soft physics
            try
            {
                await SoftPhysics.InitializeAsync(SceneState.Settings);
                _softBodyAvailable = await SoftPhysics.IsAvailableAsync();
                Console.WriteLine($"Soft physics initialized, available: {_softBodyAvailable}");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Soft physics initialization failed: {ex.Message}");
                _softBodyAvailable = false;
            }

            _initialized = true;
            
            // Subscribe to state changes with proper cleanup tracking
            _sceneStateChangedHandler = StateHasChanged;
            _simulationStateChangedHandler = StateHasChanged;
            
            SceneState.OnStateChanged += _sceneStateChangedHandler;
            SimulationLoop.OnSimulationStateChanged += _simulationStateChangedHandler;

            // Start simulation loop (SRP - loop logic extracted to service)
            await SimulationLoop.StartAsync();

            Console.WriteLine("Initialization complete");
            Console.WriteLine($"Active renderer backend: {_activeBackend}");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Initialization error: {ex.Message}");
            Console.Error.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    private async Task UpdateRendererInfoAsync()
    {
        try
        {
            var rendererInfo = await RenderingService.GetRendererInfoAsync();
            _activeBackend = rendererInfo.Backend;
            _gpuInfo = rendererInfo.Renderer ?? rendererInfo.Vendor;
            _isFallbackRenderer = rendererInfo.IsFallback;
            
            if (rendererInfo.IsFallback && !string.IsNullOrEmpty(rendererInfo.FallbackReason))
            {
                Console.WriteLine($"Using fallback renderer: {rendererInfo.FallbackReason}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to get renderer info: {ex.Message}");
            _activeBackend = "Unknown";
        }
    }

    private async Task SpawnRigidBody(RigidPrimitiveType type)
    {
        if (!_initialized)
        {
            Console.WriteLine("Cannot spawn rigid body: scene not initialized");
            return;
        }
        
        var body = new RigidBody(type, MaterialPreset.Rubber)
        {
            Transform = new TransformData
            {
                Position = new Vector3(
                    (Random.Shared.NextSingle() - 0.5f) * 4f,
                    5f + Random.Shared.NextSingle() * 3f,
                    (Random.Shared.NextSingle() - 0.5f) * 4f
                )
            }
        };

        SceneState.AddRigidBody(body);
        await RigidPhysics.CreateRigidBodyAsync(body);
        await RenderingService.CreateRigidMeshAsync(body);
    }

    private async Task SpawnSoftBody(SoftBodyType type)
    {
        if (!_initialized || !_softBodyAvailable)
        {
            Console.WriteLine("Cannot spawn soft body: scene not initialized or soft body unavailable");
            return;
        }

        var preset = type switch
        {
            SoftBodyType.Cloth => SoftBodyPreset.DrapedCloth,
            SoftBodyType.Volumetric => SoftBodyPreset.JellyCube,
            _ => SoftBodyPreset.Custom
        };

        var body = new SoftBody(type, preset)
        {
            Transform = new TransformData
            {
                Position = new Vector3(0, 5f, 0)
            }
        };

        // Default pins for different types
        if (type == SoftBodyType.Cloth)
        {
            // Pin top corners
            body.PinnedVertices.Add(0);
            body.PinnedVertices.Add(body.ResolutionX);
        }

        SceneState.AddSoftBody(body);
        
        // ISP - Using specific interface methods
        switch (type)
        {
            case SoftBodyType.Cloth:
                await SoftPhysics.CreateClothAsync(body);
                break;
            case SoftBodyType.Volumetric:
                await SoftPhysics.CreateVolumetricAsync(body);
                break;
        }

        await RenderingService.CreateSoftMeshAsync(body);
    }

    private async Task SelectObject(string? id)
    {
        SceneState.SelectObject(id);
        await RenderingService.SetSelectionAsync(id);
    }

    private async Task UpdateRigidBody(RigidBody body)
    {
        await RigidPhysics.UpdateRigidBodyAsync(body);
        SceneState.NotifyStateChanged();
    }

    private async Task UpdateSoftBody(SoftBody body)
    {
        await SoftPhysics.UpdateSoftBodyAsync(body);
        SceneState.NotifyStateChanged();
    }

    private async Task UpdateSettings(SimulationSettings settings)
    {
        SceneState.UpdateSettings(settings);
        await RigidPhysics.UpdateSettingsAsync(settings);
        await SoftPhysics.UpdateSettingsAsync(settings);
    }

    private async Task UpdateRenderSettings(RenderSettings settings)
    {
        SceneState.UpdateRenderSettings(settings);
        await RenderingService.UpdateRenderSettingsAsync(settings);
    }

    private async Task DeleteSelectedObject()
    {
        var id = SceneState.SelectedObjectId;
        if (id == null) return;

        await RigidPhysics.RemoveRigidBodyAsync(id);
        await SoftPhysics.RemoveSoftBodyAsync(id);
        await RenderingService.RemoveMeshAsync(id);
        
        SceneState.RemoveObject(id);
    }

    private void TogglePlayPause()
    {
        var settings = SceneState.Settings;
        settings.IsPaused = !settings.IsPaused;
        SceneState.UpdateSettings(settings);
    }

    private async Task ResetScene()
    {
        await RigidPhysics.ResetAsync();
        await SoftPhysics.ResetAsync();
        
        foreach (var body in SceneState.RigidBodies)
        {
            await RenderingService.RemoveMeshAsync(body.Id);
        }
        foreach (var body in SceneState.SoftBodies)
        {
            await RenderingService.RemoveMeshAsync(body.Id);
        }
        
        SceneState.ClearScene();
    }

    private async Task StepSimulation()
    {
        if (!SceneState.Settings.IsPaused) return;

        // SRP - Step logic delegated to simulation loop service
        await SimulationLoop.StepOnceAsync();
    }

    private async Task LoadPreset(string presetName)
    {
        // TODO: Load preset from samples folder
        Console.WriteLine($"Loading preset: {presetName}");
    }

    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from events to prevent memory leaks
        if (_sceneStateChangedHandler != null)
        {
            SceneState.OnStateChanged -= _sceneStateChangedHandler;
            _sceneStateChangedHandler = null;
        }

        if (_simulationStateChangedHandler != null)
        {
            SimulationLoop.OnSimulationStateChanged -= _simulationStateChangedHandler;
            _simulationStateChangedHandler = null;
        }

        // Stop simulation loop first
        await SimulationLoop.DisposeAsync();
        
        // Dispose services
        await RenderingService.DisposeAsync();
        await RigidPhysics.DisposeAsync();
        await SoftPhysics.DisposeAsync();
        await Interop.DisposeAsync();
    }
}
