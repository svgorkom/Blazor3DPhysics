@page "/"
@inject IRenderingService RenderingService
@inject IRigidPhysicsService RigidPhysics
@inject ISoftPhysicsService SoftPhysics
@inject IInteropService Interop
@inject ISceneStateService SceneState
@implements IAsyncDisposable

<div class="app-layout">
    <Toolbar OnSpawnRigid="SpawnRigidBody" 
             OnSpawnSoft="SpawnSoftBody" 
             OnPlayPause="TogglePlayPause"
             OnReset="ResetScene"
             OnStep="StepSimulation"
             OnLoadPreset="LoadPreset"
             IsPaused="@SceneState.Settings.IsPaused" />
    
    <div class="sidebar-panel panel">
        <div class="panel-header">
            <span><i class="bi bi-plus-circle"></i></span>
            <span>Spawn Objects</span>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Rigid Bodies</div>
            <div class="spawn-grid">
                <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Sphere)">
                    <span class="spawn-btn-icon"><i class="bi bi-circle-fill"></i></span>
                    <span class="spawn-btn-label">Sphere</span>
                </button>
                <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Box)">
                    <span class="spawn-btn-icon"><i class="bi bi-box-fill"></i></span>
                    <span class="spawn-btn-label">Box</span>
                </button>
                <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Capsule)">
                    <span class="spawn-btn-icon"><i class="bi bi-capsule"></i></span>
                    <span class="spawn-btn-label">Capsule</span>
                </button>
                <button class="spawn-btn" @onclick="() => SpawnRigidBody(RigidPrimitiveType.Cylinder)">
                    <span class="spawn-btn-icon"><i class="bi bi-cylinder"></i></span>
                    <span class="spawn-btn-label">Cylinder</span>
                </button>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Soft Bodies</div>
            <div class="spawn-grid">
                <button class="spawn-btn" @onclick="() => SpawnSoftBody(SoftBodyType.Cloth)" disabled="@(!_softBodyAvailable)">
                    <span class="spawn-btn-icon"><i class="bi bi-grid-3x3"></i></span>
                    <span class="spawn-btn-label">Cloth</span>
                </button>
                <button class="spawn-btn" @onclick="() => SpawnSoftBody(SoftBodyType.Rope)" disabled="@(!_softBodyAvailable)">
                    <span class="spawn-btn-icon"><i class="bi bi-bezier2"></i></span>
                    <span class="spawn-btn-label">Rope</span>
                </button>
                <button class="spawn-btn" @onclick="() => SpawnSoftBody(SoftBodyType.Volumetric)" disabled="@(!_softBodyAvailable)">
                    <span class="spawn-btn-icon"><i class="bi bi-dice-3-fill"></i></span>
                    <span class="spawn-btn-label">Jelly</span>
                </button>
            </div>
            @if (!_softBodyAvailable)
            {
                <p class="text-warning mt-sm" style="font-size: 0.75rem;">
                    <i class="bi bi-exclamation-triangle"></i> Soft body physics unavailable. Using rigid approximation.
                </p>
            }
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Scene Objects</div>
            <div class="object-list">
                @foreach (var body in SceneState.RigidBodies)
                {
                    <div class="object-item @(body.IsSelected ? "selected" : "")" 
                         @onclick="() => SelectObject(body.Id)">
                        <span class="object-icon rigid"><i class="bi bi-circle-fill"></i></span>
                        <span class="object-name">@body.Name</span>
                        <span class="object-type">@body.PrimitiveType</span>
                    </div>
                }
                @foreach (var body in SceneState.SoftBodies)
                {
                    <div class="object-item @(body.IsSelected ? "selected" : "")" 
                         @onclick="() => SelectObject(body.Id)">
                        <span class="object-icon soft"><i class="bi bi-droplet-fill"></i></span>
                        <span class="object-name">@body.Name</span>
                        <span class="object-type">@body.Type</span>
                    </div>
                }
                @if (SceneState.RigidBodies.Count == 0 && SceneState.SoftBodies.Count == 0)
                {
                    <div class="inspector-empty" style="height: 100px;">
                        <span class="text-muted">No objects in scene</span>
                    </div>
                }
            </div>
        </div>
    </div>
    
    <Viewport @ref="_viewport" CanvasId="renderCanvas" OnObjectSelected="SelectObject" />
    
    <Inspector SelectedRigidBody="@SceneState.SelectedRigidBody"
               SelectedSoftBody="@SceneState.SelectedSoftBody"
               SimulationSettings="@SceneState.Settings"
               RenderSettings="@SceneState.RenderSettings"
               OnRigidBodyChanged="UpdateRigidBody"
               OnSoftBodyChanged="UpdateSoftBody"
               OnSettingsChanged="UpdateSettings"
               OnRenderSettingsChanged="UpdateRenderSettings"
               OnDeleteObject="DeleteSelectedObject" />
    
    <Stats FPS="@_fps" 
           PhysicsTimeMs="@_physicsTimeMs" 
           RigidBodyCount="@SceneState.RigidBodies.Count"
           SoftBodyCount="@SceneState.SoftBodies.Count" />
</div>

@code {
    private Viewport? _viewport;
    private bool _initialized;
    private bool _softBodyAvailable;
    private System.Timers.Timer? _simulationTimer;
    private float _fps;
    private float _physicsTimeMs;
    private DateTime _lastFrameTime = DateTime.UtcNow;
    private float _accumulator;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            await InitializeAsync();
        }
    }

    private async Task InitializeAsync()
    {
        try
        {
            // Initialize interop
            await Interop.InitializeAsync("renderCanvas");

            // Initialize rendering
            await RenderingService.InitializeAsync("renderCanvas", SceneState.RenderSettings);

            // Initialize rigid physics
            await RigidPhysics.InitializeAsync(SceneState.Settings);
            await RigidPhysics.CreateGroundAsync(0.3f, 0.5f);

            // Initialize soft physics
            await SoftPhysics.InitializeAsync(SceneState.Settings);
            _softBodyAvailable = await SoftPhysics.IsAvailableAsync();

            // Start simulation loop
            _simulationTimer = new System.Timers.Timer(1000.0 / 60.0); // 60 FPS target
            _simulationTimer.Elapsed += async (s, e) => await SimulationTickAsync();
            _simulationTimer.Start();

            _initialized = true;
            
            // Subscribe to state changes
            SceneState.OnStateChanged += StateHasChanged;

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Initialization error: {ex.Message}");
        }
    }

    private async Task SimulationTickAsync()
    {
        if (!_initialized || SceneState.Settings.IsPaused) return;

        try
        {
            var now = DateTime.UtcNow;
            var deltaTime = (float)(now - _lastFrameTime).TotalSeconds;
            _lastFrameTime = now;

            // Clamp delta time to prevent spiral of death
            deltaTime = Math.Min(deltaTime, 0.1f);

            var physicsStart = DateTime.UtcNow;

            // Fixed timestep accumulator
            _accumulator += deltaTime * SceneState.Settings.TimeScale;
            var fixedDt = SceneState.Settings.TimeStep;

            while (_accumulator >= fixedDt)
            {
                // Step physics
                await RigidPhysics.StepAsync(fixedDt);
                
                if (_softBodyAvailable)
                {
                    await SoftPhysics.StepAsync(fixedDt);
                }

                _accumulator -= fixedDt;
            }

            _physicsTimeMs = (float)(DateTime.UtcNow - physicsStart).TotalMilliseconds;

            // Get transforms and update rendering
            var rigidBatch = await RigidPhysics.GetTransformBatchAsync();
            await Interop.CommitRigidTransformsAsync(rigidBatch.Transforms, rigidBatch.Ids);

            // Update soft body vertices
            if (_softBodyAvailable && SceneState.SoftBodies.Count > 0)
            {
                var softVertices = await SoftPhysics.GetDeformedVerticesAsync();
                foreach (var (id, data) in softVertices)
                {
                    await Interop.CommitSoftVerticesAsync(id, data.Vertices, data.Normals);
                }
            }

            // Calculate FPS
            _fps = deltaTime > 0 ? 1f / deltaTime : 0;

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Simulation tick error: {ex.Message}");
        }
    }

    private async Task SpawnRigidBody(RigidPrimitiveType type)
    {
        var body = new RigidBody(type, MaterialPreset.Rubber)
        {
            Transform = new TransformData
            {
                Position = new Vector3(
                    (Random.Shared.NextSingle() - 0.5f) * 4f,
                    5f + Random.Shared.NextSingle() * 3f,
                    (Random.Shared.NextSingle() - 0.5f) * 4f
                )
            }
        };

        SceneState.AddRigidBody(body);
        await RigidPhysics.CreateRigidBodyAsync(body);
        await RenderingService.CreateRigidMeshAsync(body);
    }

    private async Task SpawnSoftBody(SoftBodyType type)
    {
        if (!_softBodyAvailable) return;

        var preset = type switch
        {
            SoftBodyType.Cloth => SoftBodyPreset.DrapedCloth,
            SoftBodyType.Rope => SoftBodyPreset.RopePendulum,
            SoftBodyType.Volumetric => SoftBodyPreset.JellyCube,
            _ => SoftBodyPreset.Custom
        };

        var body = new SoftBody(type, preset)
        {
            Transform = new TransformData
            {
                Position = new Vector3(0, 5f, 0)
            }
        };

        // Default pins for different types
        if (type == SoftBodyType.Cloth)
        {
            // Pin top corners
            body.PinnedVertices.Add(0);
            body.PinnedVertices.Add(body.ResolutionX);
        }
        else if (type == SoftBodyType.Rope)
        {
            body.PinnedVertices.Add(0);
        }

        SceneState.AddSoftBody(body);
        
        switch (type)
        {
            case SoftBodyType.Cloth:
                await SoftPhysics.CreateClothAsync(body);
                break;
            case SoftBodyType.Rope:
                await SoftPhysics.CreateRopeAsync(body);
                break;
            case SoftBodyType.Volumetric:
                await SoftPhysics.CreateVolumetricAsync(body);
                break;
        }

        await RenderingService.CreateSoftMeshAsync(body);
    }

    private async Task SelectObject(string? id)
    {
        SceneState.SelectObject(id);
        await RenderingService.SetSelectionAsync(id);
    }

    private async Task UpdateRigidBody(RigidBody body)
    {
        await RigidPhysics.UpdateRigidBodyAsync(body);
        SceneState.NotifyStateChanged();
    }

    private async Task UpdateSoftBody(SoftBody body)
    {
        await SoftPhysics.UpdateSoftBodyAsync(body);
        SceneState.NotifyStateChanged();
    }

    private async Task UpdateSettings(SimulationSettings settings)
    {
        SceneState.UpdateSettings(settings);
        await RigidPhysics.UpdateSettingsAsync(settings);
        await SoftPhysics.UpdateSettingsAsync(settings);
    }

    private async Task UpdateRenderSettings(RenderSettings settings)
    {
        SceneState.UpdateRenderSettings(settings);
        await RenderingService.UpdateRenderSettingsAsync(settings);
    }

    private async Task DeleteSelectedObject()
    {
        var id = SceneState.SelectedObjectId;
        if (id == null) return;

        await RigidPhysics.RemoveRigidBodyAsync(id);
        await SoftPhysics.RemoveSoftBodyAsync(id);
        await RenderingService.RemoveMeshAsync(id);
        
        SceneState.RemoveObject(id);
    }

    private void TogglePlayPause()
    {
        var settings = SceneState.Settings;
        settings.IsPaused = !settings.IsPaused;
        SceneState.UpdateSettings(settings);
    }

    private async Task ResetScene()
    {
        await RigidPhysics.ResetAsync();
        await SoftPhysics.ResetAsync();
        
        foreach (var body in SceneState.RigidBodies)
        {
            await RenderingService.RemoveMeshAsync(body.Id);
        }
        foreach (var body in SceneState.SoftBodies)
        {
            await RenderingService.RemoveMeshAsync(body.Id);
        }
        
        SceneState.ClearScene();
    }

    private async Task StepSimulation()
    {
        if (!SceneState.Settings.IsPaused) return;

        await RigidPhysics.StepAsync(SceneState.Settings.TimeStep);
        
        if (_softBodyAvailable)
        {
            await SoftPhysics.StepAsync(SceneState.Settings.TimeStep);
        }

        var rigidBatch = await RigidPhysics.GetTransformBatchAsync();
        await Interop.CommitRigidTransformsAsync(rigidBatch.Transforms, rigidBatch.Ids);

        if (_softBodyAvailable && SceneState.SoftBodies.Count > 0)
        {
            var softVertices = await SoftPhysics.GetDeformedVerticesAsync();
            foreach (var (id, data) in softVertices)
            {
                await Interop.CommitSoftVerticesAsync(id, data.Vertices, data.Normals);
            }
        }
    }

    private async Task LoadPreset(string presetName)
    {
        // TODO: Load preset from samples folder
        Console.WriteLine($"Loading preset: {presetName}");
    }

    public async ValueTask DisposeAsync()
    {
        _simulationTimer?.Stop();
        _simulationTimer?.Dispose();
        
        SceneState.OnStateChanged -= StateHasChanged;
        
        await RenderingService.DisposeAsync();
        await RigidPhysics.DisposeAsync();
        await SoftPhysics.DisposeAsync();
        await Interop.DisposeAsync();
    }
}
